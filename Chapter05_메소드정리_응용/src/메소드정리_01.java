/*
 *   메소드 : 기능처리 (사용자 요청처리) => 한개의 기능만 수행이 가능하게 만드는 명령문의 집합
 *          명령문
 *           1. 변수 선언
 *           2. 연산 처리
 *           3. 제어문 처리
 *  공부 순서
 *     1.메소드 구조
 *       [접근지정어][옵션] 리턴형 메소드명 (매개변수 목록) => 선언부 (원형)
 *       {
 *           구현 ...
 *           ... ...
 *           ... ...
 *           return 값;
 *               => 메소드의 종료 => return에서 종료
 *               => return이 중간에 올 수 있다
 *               => return은 생략이 불가능 but void를 이용하는 경우에는 생략하지만,
 *                                        컴파일러에 의해 자동으로 return이 첨부된다           
 *          
 *       }        
 *      2. 
 *       접근지정어 : 다른 클래스에서 접근하는 범위
 *     ---------- public / protected / private / default => 같은 폴더에서만 접근이 가능
 *       옵션 : 
 *              1) default : 없는경우
 *              2) static : 자동 메모리 할당 => 공유할때 주로 사용
 *              3) abstract : 추상메소드 => 선언만 하는 메서드 => 프로그램에 맞게 구현해서 사용
 *                --------- 버튼 클릭할때 자주 사용 / 마우스클릭 / 키보드
 *              4) final : 종단 메소드 => 수정이 안되는 메소드
 *       리턴형 : 사용자 요청에 대한 결과값
 *             => 반드시 1개만 전송, 여러개 일때는 배열/클래스
 *                ------------ 기본형 (정수,실수,논리,문자)
 *       매소드명 : 변수 식별자와 동일
 *       매개변수 : 여러개 사용이 가능 => 사용자가 보내주는 값      
 *       메소드 호출 : 메소드를 호출시에는 메소드는 처음부터 끝까지 사용
 *               => 원래 호출한 위치로 복귀
 *             ex)
 *                  void display(){
 *                     1
 *                     2
 *                     3
 *                  }
 *                  
 *                  main () {
 *                  
 *                     1 ------- 시작 1
 *                     2 ------- 2
 *                     display(); ----------- 메소드 블록으로 이동
 *                                void 1,2,3
 *                                
 *                     3 ------- 3
 *                     4 ------- 4
 *                  }
 *             ex)
 *                  int display() {
 *                      1
 *                      2
 *                      3
 *                      return 5;
 *                  }
 *                  
 *                  main () {
 *                      (1)
 *                      (2)
 *                      int a = display(); => display 1,2,3 수행
 *                          |     |   
 *                         ---------  return값을 전송
 *                         a = 5
 *                      (3)
 *                      (4)
 *                  }
 *    메서드를 사용하는 이유
 *       => 1. 반복적인 문장이 있는 경우 (반복 제거)
 *          2. 구조적인 프로그램 => 단락 (수정, 오류처리)
 *          3. 재사용 => main은 다른 클래스에서 호출이 불가능
 *              | ==> Ctrl+c , Ctrl+v  (x)
 *              | ==> 있는 그대로 호출해서 사용
 *          4. 객체 지향 프로그램은 클래스와 클래스의 상호 연결
 *              클래스: 기능을 하는 클래스 / 조립을 하는 클래스 가있다
 *                          |                  \
 *                         CPU                메인보드 (main이 있는 클래스)
 *                         메모리 
 *                         하드디스크
 *                         사운드
 *                         ...       
 *                    -------------
 *        ex)
 *            사용자가 로그인 요청
 *            => id, pw => 매개변수
 *            => 결과값 : boolean
 *        ex)    
 *            사용자가 아이디 중복 체크를 한다고 하면 
 *            사용자가 id를 넘겨줘야 한다
 *            id => 매개변수
 *            결과값 : boolean
 *        ex)
 *            웹 => 매개변수 (이미지 클릭, 페이지번호 클릭, 입력(검색어))
 *                        화면 이동 => return값
 *                        출력할 내용이 많은 경우 => 배열 / 컬렉션 사용
 *                        
 *       매개변수 전송법
 *       ----------            
 *       1. 값 전송 ==> 메모리를 따로 만들어서 처리
 *          Call By Value
 *          기본형 ==> 원본은 유지
 *       2. 주소 전송 ==> 메모리가 같은 곳에서 전송    
 *          배열 / 클래스 => 원본이 변경
 *          Call By Reference
 *          예외) => String(일반 기본형과 동일)
 *          
 *                  
 */
public class 메소드정리_01 {
//  call by value => 실제 값만 전송 => 다른 메모리 생성 (기본형, String)
//	call by reference => 메모리 주소를 넘겨준다 => 같은 메모리 제어 (배열, 클래스)
	static void rand(int[] arr) {
		System.out.println("arr="+arr); // 주소가 같은 경우에는 같은 메모리를 제어
		for(int i=0; i<arr.length; i++){
			arr[i]=(int)(Math.random()*100)+1;
		}
	}
/*  
 *  얕은 복사 = 
 */
	public static void main(String[] args) {
//		int[] nums = new int[5];   //주소가 동일하기 때문에 자체를 변경해준다
//		System.out.println("nums="+nums);
//		rand(nums);
//		
//		for(int i:nums) {
//			System.out.print(i+" ");
//		}
		int[] arr = {10,20,30,40,50};
		int[] temp = arr;

//		temp는 arr의 별칭 => temp=arr => 기본형은 주소를 가지고 있지 않는다
//		                           => 값만 전송
		temp[1]=200;  // 자신의 메모리를 넘겨주기 때문에 변경이 될 수 있다
		System.out.println(arr[1]);
		System.out.println(temp[1]);
		
				
	}

}
