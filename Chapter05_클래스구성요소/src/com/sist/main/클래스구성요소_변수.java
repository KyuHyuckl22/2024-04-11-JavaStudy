package com.sist.main;
/*
 *    클래스 구성요소
 *    ----------- 구성요소는 3가지 형태로 나눠진다
 *    *** 클래스 블록 
 *    class ClassName
 *    {
 *       => 구현이 불가능
 *          --- 구현이란
 *            제어문 / 연산처리 / 파일 읽기 / 크롤링 / 메소드 호출 ... -->(구현을 하기 위해서는) 메소드처리, 생성자, 초기화블록을 이용해야한다
 *       => 선언만 가능하다
 *          ----------
 *          1. 변수 : 한개만 저장이 가능
 *          2. 클래스 (사용자 정의 데이터형) : 클래스와 배열은 여러개 저장이 가능
 *          3. 배열       
 *          ------------------------ 이 3개는 변수형
 *    }
 *    ------------------------------------------------------------------------------
 *      변수 : 프로그램에 필요한 데이터를 저장하는 공간 -> 프로그램 종료시까지 유지하는 변수 => 멤버변수라고 함
 *           -> 멤버변수는 자동 초기화가 default
 *    ------------------------------------------------------------------------------
 *      변수 초기화 :  (변수는 초기값이 없는 상태에서는 메모리에 저장이 안됨)
 *       = 생성자 특징 -(일반메소드와 다르다)
 *           1) 클래스명과 동일
 *           2) 리턴형이 없다 => void(리턴형)
 *              Ex)
 *                 class A
 *                 {
 *                     void A(){} => 일반 메소드
 *                     A(){} => 생성자
 *                 }
 *           3) 여러개의 생성자를 만들 수 있다
 *              ---------- 같은 이름의 메소드를 여러개 제작이 가능하다 (오버로딩(같은 이름의 메소드로 새로운 기능을 추가))
 *              -오버로딩의 특징 **** 면접 필수 
 *                1- 메소드명이 동일
 *                2- 매개변수의 갯수나 데이터형이 다르다
 *                3- 리턴형은 관계 없다
 *                4- 접근지정어는 관련이 없다
 *                Ex) 
 *                   plus (int a, int b)  
 *                   plus (double d, double d2)
 *                   plus (int a, double d)
 *                   plus (byte b, int i)
 *                   plus (char a, char b)
 *            4) 생성자의 역할 => 역할이 필요없는 경우도 있기 때문에 생략이 가능하다
 *               ** 반드시 생성자는 필요하다
 *               ** 생략이 된 경우에는 생성자를 추가 (컴파일러)
 *               1- 멤버변수의 초기화 담당
 *               2- 클래스를 메모리에 저장할때 호출되는 메소드
 *               3- 시작과 동시에 처리해야 하는 기능이 있는경우
 *                  --> 화면UI, 오라클 연결, 서버연결, 웹(자동로그인)
 *                  -----------------------------
 *                  
 *            5) 생성자 호출
 *               => new 생성자()
 *                  ---- new 없이 호출하면 오류발생
 *       = 초기화 블록 : 호출 없이 자동으로 처리
 *         {
 *             구현 후 초기화
 *         }
 *         
 *         *** 초기화 방법
 *        - 명시적인 초기화
 *           int a= 100; -> 직접 값을 입력하는 방법
 *        - 초기화 블록
 *           int a;
 *             {
 *                a=100; -> 주로 파일읽기, 웹 등 구현이 필요한 부분에서 사용
 *             }
 *        - 생성자
 *           int a;
 *           생성자()
 *           {
 *              a=100; -> 주로 파일읽기, 웹 등 구현이 필요한 부분에서 사용
 *           }
 *           
 *         ====> 저장되는 순서
 *         기본값 ==> 명시적인 초기값 ==> 초기화 블록 ==> 생성자
 *                  --------------------------------- 동시에 사용하지 않는다
 *         Ex) 
 *            class ClassName
 *            => 중복이 없는 난수값을 저장 => 명시적인 초기화가 불가능 (구현)
 *            
 *            
 *            {
 *               int a=100; 
 *               {
 *                  a=200;
 *               }
 *               
 *               ClassName()
 *               {
 *                  a=300;
 *               }
 *            }
 *            
 *        Ex)
 *            class ClassName
 *            {
 *               int a=300;
 *            }   
 *            
 *              a      a     a    a 
 *             ---    ---   ---  ---
 *              0     100   200  300  => 프로그램 시작(a=300)
 *             ---    ---   ---  ---
 *    ------------------------------------------------------------------------------
 *     *    메서드 :   특정 기능을 수행하는 명령문의 집합
 *          --------
 *          검색, 목록, 페이지 나누기, 예약, 결제, 회원 가입, 회원 탈퇴
 * 
 *          1. 재사용이 좋다.
 *          2. 기능 별로 나눠져있어 => 수정하기 편리하다.
 *          3. 반복 기능을 제거할 수 있다.
 *          4. 구조적인 프로그램을 만들 수 있다. (2번과 동일)
 *          5. 역할 : 기능을 수행하거나, 다른 클래스와 연결하는 역할을 한다
 *                               ------------------------ ** 핵심
 *          =>   객체 지향 프로그램 
 *             여러 개를 모아서 조립하는 프로그램 => 다른 클래스와 연동.
 *    기능
 *       CPU / HD / monitor / memory ==> 기능을 구현
 *       ---------------------------
 *                |
 *             main board
 *       => 클래스 1개 == 부품 => 조립 (CBD)
 *                            Component : 클래스 (한 개의 기능) ===>> 메서드가 여러 개 묶이면 한 개의 컴포넌트라고 한다.)
 *                            => 여러 개 만들어 => 조립 => 레고와 같은 개념
 *                            => 묶어주는 역할 : Container
 *  140p => 메서드 형식
 *          [접근지정어] [옵션] 리턴형 메소드명(매개변수목록)  => 선언부
 *          {              ---- 데이터형
 *              // 구현
 *              return 값  --> 데이터형에 해당되는 값
 *              // void (결과값이 없는 경우) => return 생략이 가능하다
 *          }
 *          ** 접근지정어
 *           private : 자신의 클래스 안에서만 사용 => 다른 클래스와 연결할 수 없다 => 멤버변수 (데이터보호)
 *                                            --------------------
 *           default : 키워드가 없는 상태 => 같은 패키지 안에서만 접근이 가능
 *           protected : 같은 패키지 안에서만 접근이 가능 + 상속을 받은 경우에는 다른 패키지 접근이 가능
 *           public : Open 모드 => 패키지와 관계없이 모든 클래스에서 접근이 가능                                          
 *           
 *          *** private : 접근 거부 => 다른 클래스에서 사용이 안됨 => 개인정보 => 멤버변수
 *               => 메소드 (변수의 기능)
 *                        -------- 변수의 기능은 메모리에 저장 / 메모리값 읽기  이 두가지다
 *                                           --------     --------
 *                                           setter         getter
 *                                  사용법 ->  set변수명()      get변수명()
 *                                  => 변수는 메모리에 값이 저장 => 노출될 염려가 있음 -> 노출이 되면 변경, 상실 될수 있음
 *                                  => 메소드는 주소값만 저장되어있기 때문에 노출되지 않음
 *                                  ----------------------------------------- 이 두가지 방식이 캡슐화 이다
 *                                  
 *          *** public : 접근이 가능 => 다른클래스와 연결가능 => 생성자 / 클래스 / 메소드 / 인터페이스 (변수빼고는 다 퍼블릭)
 *           --------------------------------------------------------------------------------------
 *           
 *           접근 지정어 사용 방법
 *           ---------------
 *           클래스
 *           [접근지정어][옵션] class ClassName
 *           {
 *           }
 *           - 접근 지정어 : 보통 public 사용 => 다른 클래스와 연결
 *           - 옵션 : static / abstract / final
 *           
 *           생성자 : 다른 클래스와 연결되야함 
 *           [접근지정어] 클래스명()
 *           {
 *             => 구현부
 *           }
 *           - 접근지정어 : 거의 public
 *            
 *           멤버변수
 *           [접근지정어] [옵션] 데이터형 변수명 
 *           접근지정어 - private, public ---> 라이브러리 클래스, 버튼, 테이블 등 노출해도 상관없는 애들
 *                     ------> 개인정보, 회사정보 등 노출하면 안되는 정보들
 *           옵션 - static : 공통으로 사용하는 변수 => 메모리 공간 1개만 만든다
 *           변수명 - 클래스, 배열
 *           
 *           ** 일반 => 인스턴스 : 메모리가 따로있다
 *           ** 데이터 묶음 => static => 데이터 관리
 *              회원목록 / 게시판 목록 => 한개만 가지고 사용
 *           -------------------------------------------------------
 *           메소드 : 다른 클래스와 연결
 *           [접근지정어][옵션] 리턴형 메소드명 (매개변수 목록)
 *           접근 지정어 - pubric static abstract
 *           옵션 - static
 *           리턴형 - 기본형, 배열, 클래스
 *           매개변수 목록 - 0개 이상 => 매개변수 3개이상 추가하지 않는다(3개 이상이면 배열/클래스)
 *           
 *            ------
 *            public     static  |  abstract
 *                       -----공통으로 사용
 *            {
 *                 구현
 *            }
 *            
 *            => 경우의 수 
 *            --------------------------------------
 *                    리턴형             매개변수
 *                요청 처리값              사용자 요청값
 *            --------------------------------------
 *                     ㅇ                   ㅇ    => String 
 *                                                  String substring(int s, int e)
 *                                                  s 부터 e 까지 자른 문자열을 달라
 *            --------------------------------------
 *                     ㅇ                   ㄴ    => String trim() => 공백을 제거한 문자열
 *                                              => String toUpperCase() => 대문자로 변환후에 문자열출력
 *            --------------------------------------
 *                     ㄴ                   ㅇ    => void System.out.println(String s)
 *                                                   s 를 출력하라
 *                                              => 메소드 자체 처리 => 결과값이 없다 void
 *                                              => 오라클에 추가, 수정, 삭제 == 오라클 자체에서 처리하기 때문에 리턴형이 거의 없다
 *            --------------------------------------
 *                     ㄴ                   ㄴ    => 사용 빈도가 거의 없다
 *            --------------------------------------
 *           ---------------
 *           *** 자바 / 오라클 => 공부를 많이 ...
 *           *** Spring
 *           ----------------------------------------------------
 *       => 메서드 호출
 *          class A
 *          {
 *              private int a;
 *              private int b;
 *              private static int c;  => 저장
 *              private void aaa(){}
 *              private static void bbb(){} => 저장
 *              private int ccc;
 *              private static int ddd(){} => 저장
 *              
 *              static => 메소드/변수 는 컴파일시에 저장
 *              나머지는 값을 줘야 저장
 *          }
 *          static 저장 => Method Area
 *          ----------
 *           --------
 *              0 ---> c  호출하기 방법 => A.c => 클래스명.변수
 *           --------
 *             bbb()      호출하기 방법 => A.bbb => 클래스명.메소드명()
 *           --------
 *             ddd()      결과값을 받는다 =>  int result =A.ddd()
 *          ----------                    |         --------- 리턴형이 있는 경우에는 결과값을 받아서 저장
 *                 A  aa=new A();         |리턴에 사용된 데이터형보다 크거나 같아야 한다
 *                 
 *                   Stack                    Heap
 *                  ---aa---
 *                   0x100   => 메모리 주소에있는 매소드나 변수를 가지고 온다 : '.'  .은 메모리 주소 접근 연산자
 *                  --------         0x100  ---------
 *                                             
 *                                          ---------
 *                                             0 -> a  => 객체명.변수명 => aa.a
 *                                          ---------
 *                                             0 -> b  => aa.b
 *                                          ---------
 *                                            aaa()    => 객체명.메소드명 => aa.aaa()
 *                                          ---------
 *                                            ccc()    => aa.ccc()
 *                                          ---------    리턴형이 있는경우
 *                                                      int result = aa.ccc()
 *                                                            |      -------
 *                                                            |________|
 *                                                            aa.ccc() 의 값을 result 에 저장
 *        메소드 수행
 *        
 *        public int aaa()
 *        {
 *          1.문장
 *          2.문장
 *          3.문장
 *          return 10;
 *        }
 *        
 *        int a=aaa() =>호출
 *        1.문장
 *        2.문장
 *        3.문장
 *        ========> a에 10을 대입한다 ===밑에 문장 수행
 *        호출 => 메소드에 있는 모든 문장을 수행 => 호출된 위치 복귀
 *        ---------------------------------------------
 *        ** 메소드는 호출시마다 => 메소드 처음부터 다시 수행
 *        
 *    ----------------------------------------------------------------------------------------------------
 *    => 패키지 / 임포트
 *    => 데이터 보호 : 캡슐화
 *    => 상속 / 포함
 *    => 오버라이딩 / 오버로딩
 *    ----------------------- 객체 지향 프로그램
 *    예외처리 / 클래스 종류 / 라이브러리 사용 / 구현
 *    
 *    *** 개념 ==> 면접볼때 사용
 *       => 1- 형식
 *          2- 사용방식 -> 메소드 호출, 초기화
 *          3- 조립방식 -> 기능
 *         --------- 이 외 요구사항 분석 연습하기 => 잘 모르면 구글링 / GPT 
 *      개념 => 자바 / Spring 에서 나온다 
 *      라이브러리--> 자료구조 : 데이터들을 쉽게 관리하는것
 *      
 *      *** 프로그램의 구현 => 마음대로
 *      *** 프로그램 => 분석 (코드를 보자마자 어떤거구나 하고 알게된다면 7개월 과정? 충분히 성공)
 *      *** 프로그램에서는 특별한 경우가 아니면 static 메소드는 사용 빈도가 거의 없다
 *                                    ----------- 데이터베이스 / 네트워크
 *                                    왜냐하면 동시접속이 가능하게 따로따로 만들어줘야하기 때문
 *                                    공용으로 만들면 1명이 다 사용한 이후에 다음사람이 들어가야하기 때문
 *      
 */
public class 클래스구성요소_변수 {
//  저장이 안된 => 인스턴스 (new를 이용해서 저장한다)
/*
 *     인스턴스 : 객체
 *     ----- 클래스의 내용 (메소드, 변수) => 메모리에 저장한 상태 => 각자 따로 저장 => new를 이용해야 사용이 가능
 *     
 *     인트턴스 : 변수 / 메소드 ******************
 *     static : 변수 / 메소드
 *     
 *     Class A
 *     {
 *         private int a=10; => 객체 자신이 가지고 있는 변수
 *         private static int b=20; => 객체마다 공통으로 사용되는 변수
 *         
 *         public void aaa() => 객체 자신이 가지고 있는 메소드
 *         {
 *             => ccc() / a / b  - 사용 가능
 *         }
 *         public static void bbb() => 객체마다 공통으로 사용되는 메소드
 *         {
 *             => b만 사용이 가능 => static 에서는 static으로 선언된 변수, 메소드만 가능
 *             => aaa(),bbb(),a
 *             A aa=new A(); => 객체 선언후 사용이 가능
 *             aa.aaa()
 *             aa.bbb()
 *             aa.a
 *         }
 *         public void ccc() ccc
 *         {
 *             => aaa() / a / b
 *         }
 *         인스턴스 메소드는 클래스에 있는 모든 메소드를 자유롭게 사용할 수 있다
 *     }
 */
	public void aaa()
	{
		System.out.println("aaa() 진입 ...");
		bbb();
		System.out.println("aaa() 종료 ...");
	}
	public void bbb()
	{
		System.out.println("bbb() 진입 ...");
		ccc();
		System.out.println("bbb() 종료 ...");
		//return을 생략하면 자동으로 추가가 된다. 지금 return이 들어가있는것
	}
	public void ccc()
	{
		System.out.println("ccc() 진입 ...");
		System.out.println("ccc() 종료 ...");
	}
	public static void main(String[] args) {
//    객체 생성 후 메소드를 사용할 수 있다
	    클래스구성요소_변수 aa=new 클래스구성요소_변수();
	    aa.aaa();
	}

}
