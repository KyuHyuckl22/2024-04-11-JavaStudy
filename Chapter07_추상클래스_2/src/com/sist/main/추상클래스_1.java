package com.sist.main;
/*
 *   일반 클래스
 *     구성 요소
 *       class CalssName
 *       {
 *         ----------------------------------------
 *          변수
 *            => 따로 저장 변수 : 인스턴스 => 새로운 메모리 공간을 만들어서 저장
 *                                      ------------ new
 *            => 한개를 가지고 사용하는 변수 => static 
 *         ----------------------------------------
 *          생성자 : 변수에 대한 초기화
 *                윈도우 / 웹 / 데이터베이스 : 시작과 동시에 처리
 *                화면 UI / 자동 로그인, 쿠키 / 드라이버 등록
 *            => 반드시 필요하다 이유는 메모리 저장시에 호출해야하기 때문
 *              -> 없는 경우에는 컴파일러에 의해 자동으로 추가된다 (필요없는 경우에는 생략할 수 있다)
 *            => 여러개를 만들 수 있다
 *              -> 디폴트 생성자 : 매개변수가 없는 생성자
 *              -> 매개변수가 있는 생성자 => 사용자로부터 초기값을 받아서 저장할때
 *              -> 클래스내에서 생성자를 호출할때는 this() 를 이용한다
 *                                        ------ 생성자 내에서만 호출 가능 => 한번만 호출 / 첫줄에 사용한다
 *                                        super() 는 상속을 받은 경우에 사용
 *              -> 자동처리 => 컴파일러에 처리
 *                1. 모든 클래스는 Object 상속을 받는다 => Object 상속을 생략할 수 있다
 *                  public class A extends Object
 *                                 ---------------
 *                          => Object 에서 제공하는 모든 기능 사용이 가능
 *                            => 객체 비교 : equals()
 *                            => 소멸자 : finalize()
 *                            => 복제 : clone()
 *                            => 주소 출력 : toString()
 *                2. import 가 생략
 *                   import java.lang.*;
 *                          -------------- String, Math, System .. import 를 붙이지 않고 사용 가능한것들
 *                3. 메소드 
 *                   void => return 을 생략하면 => 자동으로 추가
 *                4. 상속
 *                   class A
 *                   {
 *                   }
 *                   
 *                   class B extends A
 *                   {
 *                     public B()
 *                     {
 *                       super()
 *                       ---------생략
 *                       * 생략할 수 없는 내용 : 상속을 내리는 클래스의 생성자가 매개변수를 가지고 있는 경우에는 생략할 수 없다
 *                     }
 *                   }
 *                ==> super() (상위 클래스의 메모리 할당) => 자신의 메모리 할당
 *                  --------------------
 *                    ---- super ----
 *                     상속받은 변수/메소드
 *                    ---------------
 *                    ---- this ----
 *                     추가된 변수/메소드
 *                    --------------
 *                  --------------------- this, super 에 있는 변수, 메서드 사용이 가능하다
 *                  
 *                5. 예외처리가 생략 => 자바의 모든 클래스는 예외처리를 가지고 있다
 *                   -----> 에러 방지 => 에러(소스상에서 수정할 수 없는 에러) / 예외처리(소스상에서 수정이 가능한 에러)
 *                                    메모리 할당할 공간이 없습니다           정수 => 문자열
 *                         --------------------------------------------------------------------------------
 *                   컴파일시 예외처리 : javac - 파일 입출력, 네트워크, 쓰레드, 데이터베이스처리, 웹 ... 은 반드시 예외처리를 가져가줘야함
 *                   실행시 예외처리  : java (생략이 가능)
 *         ----------------------------------------
 *         => 기능처리 (사용자 요청 처리) => 메소드
 *           => 요청은 한개만 요청이 가능하게 만든다
 *           => 메소드는 반드시 한개 요청에 대한 처리만 한다
 *             -> 에러 빈번하게 일어나는 이유
 *                1) 사용자 입력 (요청값 오류)
 *                2)**** 프로그래머의 실수 ******
 *                  3.3 대란 
 *                  ------ 씨티은행 (3개월동안 온라인으로 입출금)
 *                  
 *         -----------------------------------------
 *         
 *         메소드 : 구현을 반드시 해야한다 
 *           선언부 
 *           {
 *           
 *           } // 메모리 저장 
 *           
 *         
 *       }
 *   추상 클래스 : 사용자 정의는 거의 없다 => 확장된 개념(인터페이스)
 *            => 라이브러리에 추상클래스가 많이 존재
 *               ------ 상속 => 왜 오버라이딩을 하는 이유
 *                            -------------------
 *                            메모리 할당을 할 수 없다 => 미완성 클래스 => 메소드 구현이 안된경우
 *     => 구현이 안된 메소드를 포함 => 미완성된 클래스
 *        [접근지정어] abstract class ClassName
 *        { 
 *          ----------------------------------------
 *           변수는 일반 클래스와 동일
 *          ----------------------------------------
 *           생성자
 *          ----------------------------------------
 *           구현된 메소드 : 상속받은 클래스가 동일한 기능을 수행
 *          ----------------------------------------
 *           구현이 안된 메소드 : 상속받은 클래스 마다 기능은 동일한데 구현이 다른 경우 => 선언 
 *           ------------- 추상메소드
 *          ----------------------------------------
 *           [접근지정어] abstract 리턴형 메소드명(매개변수..)
 *           => 프로그램에 맞게 구현을 해서 사용한다
 *          ----------------------------------------
 *         } 
 *          => 주로 사용되는 곳은 클래스마다 기능은 동일한데 구현 내용이 다를경우 , 선언, 유지보수가 편리하게 만든다
 *          => 사이트마다 약간씩 틀리다
 *             ------------------ 로그인, 로그아웃, ... 회원가입 ...
 *             => 네이버 => Ajax
 *             => 네이트 => 일반 JSP
 *             => 아시아나항공 => VueJS ... 
 *             --------------------------
 *             => 벤치마킹 => 기능 (설계) => 추상클래스
 *          => 상속이 안되는 소스가 있다
 *            1) 생성자, static, 초기화 블록 => 상속 (변수, 메소드)
 *            -> 오버라이딩 프로그램
 *               ------- 일반클래스, 추상클래스, 인터페이스
 *               = 메소드명 동일, 매개변수 동일, 리턴형 동일, 접근지정어는 다를 수 있음
 *             
 *            ex) 
 *            abstract class A {
 *              abstract void display(); --> 상속을 내리면 반드시 구현해서 사용
 *            }
 *            
 *            class B extends A {
 *              void display(){}
 *              => 동일
 *              --------------------------------
 *              protected void display(){}
 *              public void display(){}
 *              -----------------------------------> 접근범위 확장이 가능ㅎ다ㅏ
 *              => 잘 모르는 경우에는 public 
 *            }
 *            
 *            interface A {
 *              void display(); => 선언만 된 메소드만 가지고 있다
 *            }
 *         
 *         	class B implements A {
 *            public void display(){} => 오류 발생   
 *         {
 *                           
 *         =====> 인터페이스 이해 ==> Spring  스프링은 이 셋을 포함하고 있다
 *                               java / 오라클 / jsp  
 *                               
 */
class A {
	//public A(){}
}
class B extends A {
	public B() {
//		super() 생략 가능
	}
}
class C {
	public C(int a) {// 매개변수를 가져오게 된다면 상속을 받는 클래스가 오류
		
	}
}
// D : 하위 클래스 , C : 상위클래스 => this, super
class D extends C {//  상위 클래스가 매개변수가 있는 경우에는 반드시 super 을 이용해서 호출해야 사용이 가능
	public D() {
		super(10);//  사용자 정의는 거의 없다 => 라이브러리에서 호출시에 반드시 super() 호출
//		              super(), this() => 생성자내에서 호출이 가능, 반드시 첫줄에서 호출한다 
//		              둘중 하나 만 호출 할 수 있다
//		              상위 클래스 제어 => super, 생성자 super()
//		              자신 클래스 제어 => this, 생성자 this()
	}
}
abstract class AAA {
	public abstract void display();
}

public class 추상클래스_1 {

	public static void main(String[] args) {
		A a=new A();
		B b=(B)a;
	}

}
